{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p><code>pcg_skel</code> is a package used to rapidly build neuronal skeletons from electron microscopy data in the CAVE ecosystem. It integrates structural data, connectivity data, and local features stored across many aspects of a CAVE system, and creates objects as MeshParty meshes, skeletons, and MeshWork files for subsequent analysis. By harnessing the way the structural data is stored, you can build skeletons for even very large neurons quickly and with little memory use.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install <code>pcg_skel</code>, just use pip. The package is available for python 3.9 and above.</p> <pre><code>pip install pcg_skel\n</code></pre>"},{"location":"#installing-from-source-for-developers","title":"Installing from Source (for Developers)","text":"<p>To install <code>pcg_skel</code> from source, you can clone the repository and install it using pip.</p> <pre><code>pip install -e .\n</code></pre> <p><code>pcg_skel</code> uses uv for packaging, and there are tests that can be run within the environment using poe</p> <pre><code>poe test\n</code></pre> <p>which aliases <code>uv run pytest --cov=pcg_skel tests</code>.</p>"},{"location":"#related-packages","title":"Related Packages","text":""},{"location":"#meshparty","title":"MeshParty","text":"<p><code>pcg_skel</code> uses MeshParty for skeletonization and mesh processing, and relies on algorithms and data classes defined there.</p>"},{"location":"#caveclient","title":"CAVEclient","text":"<p><code>pcg_skel</code> uses the CAVEclient to access data stored in the CAVE ecosystem.</p>"},{"location":"#skeletonplot","title":"SkeletonPlot","text":"<p>SkeletonPlot can be used to visualize skeletons generated by <code>pcg_skel</code>.</p>"},{"location":"background/","title":"Background","text":""},{"location":"background/#background","title":"Background","text":"<p>Skeletonization is an essential part of measuring neuronal anatomy, but in 3d segmented data it is not always trivial to produce a skeleton. Segmentations and meshes are often prohibitively large to download en mass and can have artifacts that generate ambiguities or make attaching annotations like synapses to specific locations unclear.</p> <p>PCG-skel uses the same chunking that allows the PyChunkedGraph (PCG) to quickly make edits to large, complex neuronal segmentations and, combined with a dynamic caching system that updates after every edit, can generate complete representations of the topology of objects in just a few seconds and minimal data downloads. Becuase the data is always matched to the underlying representation of the segmentation, there are no ambiguities in what parts are connected to what other or in which vertex a synapse or other annotation is associated with. Light data needs and rapid skeletonization make it useful in environments where analysis is being re-run on frequently changing cells.</p> <p>However, there is a trade-off in terms of resolution. The dependency on chunk size means that vertices are roughly a chunk width apart, which in current datasets like Microns amounts to about 2 microns. Thus for understanding the overall structure of a cell or looking at long distance relationships between points along an arbor, these skeletons are quite good, but for detailed analysis at short length scales (0-10 microns or so) where being plus or minus a micron would hurt analysis, we recommend looking at other approaches like kimimaro, meshteasar, or CGAL skeletonization.</p>"},{"location":"background/#key-terms","title":"Key terms","text":"<p>Ids in the PCG combine information about chunk level, spatial location, and unique object id. This package uses the highest-resolution chunking, level 2, to derive neuronal topology and approximate spatial extent. For clarity, it's useful to define a few terms:</p> <ul> <li>Level 2 chunk: A box defining a unit of data storage and representation. The entire dataset is tiled by nonoverlapping chunks. Each chunk has properties like a detailed graph of which supervoxels touch what other supervoxels, meshes associated with each segmented object inside the chunk, etc. By chunking the data and agglomerating larger objects out of these chunks, edits only have to touch those few chunks that actually change during proofreading, reducing the amount of memory and effort needed to process them.</li> </ul> <p>Chunks can exist at many scales, but \"level 2\" refers to the lowest level of chunking (level 1 refers to the supervoxels themselves).</p> <ul> <li> <p>Level 2 id (L2 id): A segmentation id that describes the state of the segmentation inside a given L2 chunk. Note that if two distinct parts of the same neuron enter the same chunk, each has its own level 2 id.</p> </li> <li> <p>Level 2 graph: Each level 2 id can be thought of as connected to level 2 ids in other chunks when an object's supervoxels run across chunk boundaries or where edges have introduced by merges during proofreading. The graph of which level 2 ids are connected to which others is called the \"level 2 graph.\" Keeping track of the level 2 graph is one of the jobs of the PCG.</p> </li> <li> <p>Level 2 skeleton: A reduced version of the level 2 graph that is tree-like.</p> </li> <li> <p>Representitative point: For each level 2 id, the L2 Cache determines a representative point that is guaranteed to be within the segmentation and is located at a \"most central\" point in the segmentation of the L2 id.</p> </li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p><code>pcg_skel</code> aims to follow semantic versioning, such that major versions are potentially backward-incompatible, minor versions add new features, and patch versions are bug fixes. This changelog is a summary of the changes in each version.</p>"},{"location":"changelog/#122","title":"[1.2.2]","text":"<ul> <li>Fixed <code>chunk_tools.get_closest_lvl2_chunk</code> to correctly handle out-of-date root ids.</li> </ul>"},{"location":"changelog/#121","title":"[1.2.1]","text":""},{"location":"changelog/#fixes","title":"Fixes","text":"<ul> <li>Fixed various issues with meshwork rehydration.</li> </ul>"},{"location":"changelog/#120","title":"[1.2.0]","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Added hydration of meshwork objects from the new-ish CAVE skeleton service.</li> </ul>"},{"location":"changelog/#110","title":"[1.1.0]","text":""},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>Added <code>add_synapse_count</code> and <code>aggregate_property_to_skeleton</code> functions to <code>features</code> module.</li> <li>Updated tests to use the <code>CAVEclientMock</code> feature introduced in CAVEclient 6.4.0.</li> </ul>"},{"location":"changelog/#107","title":"[1.0.7]","text":""},{"location":"changelog/#fixes_1","title":"Fixes","text":"<ul> <li>Fixed errors arising from in mesh-to-skel-map for single vertex root ids.</li> </ul>"},{"location":"changelog/#106","title":"[1.0.6]","text":""},{"location":"changelog/#fixes_2","title":"Fixes","text":"<ul> <li>Fixed errors arising from running pcg_graph, pcg_skeleton, or pcg_meshwork on a root id with only a single vertex.</li> </ul>"},{"location":"changelog/#105","title":"[1.0.5]","text":""},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>Adds an optional <code>return_quality</code> argument to <code>features.add_is_axon_annotation</code> to optionally return the split quality value.</li> </ul>"},{"location":"changelog/#104","title":"[1.0.4]","text":""},{"location":"changelog/#fixes_3","title":"Fixes","text":"<ul> <li>Raise a clear error when a level 2 cache service, which is needed, is not available.</li> </ul>"},{"location":"changelog/#103","title":"[1.0.3]","text":""},{"location":"changelog/#fixes_4","title":"Fixes","text":"<ul> <li>Fixed the <code>features.add_is_axon_annotation</code> function to warn rather than raise an error when the split quality is poor.</li> </ul>"},{"location":"changelog/#102","title":"[1.0.2]","text":""},{"location":"changelog/#fixes_5","title":"Fixes","text":"<ul> <li>Fixed the dictionaries returned with <code>pcg_skeleton</code>, such that one maps skeleton vertices to l2 ids and the other maps l2 ids to skeleton vertices. Previously, the first dictionary was repeated twice.</li> </ul>"},{"location":"changelog/#101","title":"[1.0.1]","text":""},{"location":"changelog/#changes","title":"Changes","text":"<ul> <li>In pcg_graph, pcg_skeleton and pcg_meshwork, you can now pass the result of <code>client.chunkedgraph.level2_chunk_graph</code> directly as an argument (<code>level2_graph</code>) to avoid recomputing the graph and level2 features if you already have it around. The format is a list of pairs of level 2 ids.</li> </ul>"},{"location":"changelog/#100","title":"1.0.0","text":""},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>The principle functions (<code>pcg_skeleton</code>, <code>pcg_meshwork</code>, and <code>pcg_graph</code>) all now use the chunkwise cache on the PCG, rather than an older approach that had to involve mesh data. The old function names (<code>coord_space_*</code>) are now deprecated, but will work until the next major version.  The previous functions are now available in the <code>pcg_skel.nocache</code> module.</li> <li>In <code>pcg_meshwork</code>, if synapses are requested and no synapse table is specified, the default synapse table will be used.</li> <li>In <code>pcg_meshwork</code>, <code>synapses=True</code> will now return both pre and postsynaptic annotations.</li> <li>In <code>pcg_meshwork</code>, there is now a <code>synapse_point_resolution</code> argument that determines the resolution of the synapse points returned. By default, this value will be <code>[1,1,1]</code> (x,y,z resolution), indicating that points should be in nanometers, the same units as the vertices.</li> <li>In <code>pcg_meshwork</code>, there is now the option to specify the name of the pre and post synapse columns to use as representitiative points in a synapse table.</li> <li>Added <code>pcg_skeleton_direct</code> function that expects vertices and edges from an already computed L2 graph.</li> </ul>"},{"location":"changelog/#changes_1","title":"Changes","text":"<ul> <li> <p>In <code>pcg_meshwork</code>, when requesting synapses the partner root ids are not returned by default. Accordingly, <code>nrn.anno.pre_syn.df</code> will not have a <code>post_pt_root_id</code> field, and <code>nrn.anno.post_syn.df</code> will not have a <code>pre_pt_root_id</code> field. This is to avoid confusion, because these fields can quickly become stale. If you need them, you can still get them by using the <code>synapse_partners=True</code> argument. However, the supervoxel ids are returned, which both do not change and also let you look up root ids when needed. Otherwise, you can use </p> <pre><code>client.chunkedgraph.get_roots(nrn.anno.pre_syn.df['post_pt_supervoxel_id'], timestamp)\n</code></pre> <p>to get the post-synaptic root ids for a list of supervoxels at a particular timestamp, and similar for the pre-synaptic root ids.</p> </li> <li> <p>In <code>pcg_meshwork</code>, the resolution of the synapse points has changed. It will now be in nanometers, not voxel dimensions that could change with different datasets. This means that the locations in the <code>nrn.anno.pre_syn.df</code> and <code>nrn.anno.post_syn.df</code> dataframes will already be in the same coordinates as vertices without an additional conversion step.</p> </li> </ul>"},{"location":"changelog/#notes-for-upgrading","title":"Notes for upgrading.","text":"<p>1) If you are using the <code>pcg_skel.coord_space_*</code> functions, you should switch to the <code>pcg_*</code> function names.</p> <p>2) If you are using synaptic partners from meshwork objects directly, you need to set the <code>synapse_partners=True</code> argument.</p> <p>3) If you are using synapse points, the default resolution has changed to nanometers. If you hard-coded the old resolution, you should update your code to reflect this change. This will not affect distances measured along the arbor of the neuron that use the graph topology, only spatial properties like <code>ctr_pt_position</code>.</p>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#before-using-pcg_skel","title":"Before using pcg_skel","text":"<p>Before you can use pcg_skel, you need to have a functioning CAVEclient setup, including token, for your dataset. This tutorial will use the <code>minnie65_public</code> dataset as an example, which can be set up by following the instructions at this link.</p>"},{"location":"tutorial/#generating-a-skeleton","title":"Generating a skeleton","text":"<p>To get a skeleton requires only a root id and a caveclient, but there are many options to customize the skeletonization process.</p> <p>At its most basic, we are going to get a skeleton for a single neuron in the <code>minnie65_public</code> dataset and the v795 data release.</p> <pre><code>import caveclient\nimport pcg_skel\n\ndatastack = 'minnie65_public'\nclient = caveclient.CAVEclient(datastack)\nclient.materialize.version = 795 # Ensure we will always use this data release\n\nroot_id = 864691135397503777\nskel = pcg_skel.pcg_skeleton(root_id=root_id, client=client)\n</code></pre> <p>The above code will generate a skeleton for this neuron (Link to Neuroglancer, needs the same credentials as above).</p> <p>You can, for example, check the overall path length of the cell with <code>skel.path_length()</code> and find more features in the Meshparty documentation.</p> <p>However, this may not be the skeleton you want most. For example, the location of the root node will be a random end point and thus the orientation of the skeleton will be arbitrary.</p> <p>To control the location of the root node and the behavior around the cell body, there are several key parameters:</p> <ul> <li> <p>root_point, root_point_resolution: Setting a root point defines the root of the skeleton, which establishes an orientation for the skeleton. Root point is an x,y,z position, and the resolution is the value in nm of the resolution of coordinates (also in x,y,z, resolution). If the point is from neuroglancer or an annotation table, take careful note of the resolution. </p> </li> <li> <p>collapse_soma, collapse_radius: These two options let you collapse vertices around a soma into the root point. Setting collapse_soma to True will collapse all vertices within the collapse radius (in nanometers) into the root point. Additionally, the root point is added as a new skeleton vertex. Again, the default value works for most cortical neurons, but cells with larger or smaller cell bodies might need different values.</p> </li> </ul> <p>In addition, the skeletonization process has a minimum scale such that branches shorter than this are not included in the skeleton. This is set by the <code>invalidation_d</code> parameter, which is the distance in nanometers at which vertices are collapsed into a branch. This is an important parameter to customize for your data, since different morphologies will be best represented by different values. The default value works well for cortical neurons, for example, but is probably too coarse for fly neurons. This is controlled with:</p> <ul> <li>invalidation_d: The invalidation distance for skeletonization, in nanometers. This parameter sets the distance at which vertices of the graph are collapsed into a branch. Too big and branches might be missed, but too small and false branches might be added to thick processes.</li> </ul> <p>There are also several adminstrative parameters, such as:</p> <ul> <li> <p>cv: Passing an initialized cloudvolume object (<code>cv=</code>) can save a second or two per skeleton. This isn't a big deal for a couple of skeletons, but may save real time if you are creating a large number of skeletons.</p> </li> <li> <p>return_mesh, return_l2dict, return_l2dict_mesh: These three values are all set to False by default, which is fine if you just want a skeleton. However, if you want to map vertices to level 2 ids or skeleton vertices back to the mesh graph, these options can give you the mesh and dictionaries mapping vertices to the l2 ids for the skeletons and the mesh graph.</p> </li> </ul> <p>A more complete version of the above code might look like:</p> <pre><code>import caveclient\nimport pcg_skel\n\ndatastack = 'minnie65_public'\nclient = caveclient.CAVEclient(datastack)\nclient.materialize.version = 795 # Ensure we will always use this data release\n\nroot_id = 864691135397503777\n\n# Get the location of the soma from nucleus detection:\nroot_resolution = [1,1,1] # Cold be another resolution as well, but this will mean the location is in nm.\nsoma_df = client.materialize.views.nucleus_detection_lookup_v1(\n    pt_root_id = root_id\n    ).query(\n        desired_resolution = root_resolution\n    )\nsoma_location = soma_df['pt_position'].values[0]\n\n# Use the above parameters in the skeletonization:\n\nskel = pcg_skel.pcg_skeleton(\n    root_id,\n    client,\n    root_point=soma_location,\n    root_point_resolution=root_resolution,\n    collapse_soma=True,\n    collapse_radius=7500,\n)\n</code></pre> <p>Now you can see that the root position aligns with the soma location by going to the position specified at <code>skel.root_position / [4,4,40]</code> in the Neuroglancer link above. Note the elementwise division, because the resolution of the <code>minnie65_public</code> neuroglancer link is <code>[4,4,40]</code> nm/voxel.</p>"},{"location":"tutorial/#generating-a-meshwork","title":"Generating a meshwork","text":"<p>Meshwork objects are a way to simultaneously track neuronal morphology like the skeleton as well as annotations and labels like synapses or compartments.</p> <p>Most of the information needed to generate a meshwork is the same as for a skeleton. For convenience, however, synapses can be queried and added to the object by default and this comes with a few extra parameters.</p> <p>Starting from where we were before, you can generate a meshwork for that same neuron with virtually the same arguments, plus <code>synapses=True</code>:</p> <pre><code>nrn = pcg_skel.pcg_meshwork(\n    root_id = root_id,\n    client = client,\n    root_point = soma_location,\n    root_point_resolution = root_resolution,\n    collapse_soma = True,\n    collapse_radius = 7500,\n    synapses=True,\n)\n</code></pre> <p>All meshwork objects created this way will have an annotation table <code>lvl2_ids</code> that has the level 2 id of each vertex in the meshwork graph. This is useful for mapping synapses or other annotations back to the meshwork.</p> <p>Now you can glance at some of the synapses through the <code>nrn.anno</code> attribute. Presynaptic sites (outputs) are put under <code>nrn.anno.pre_syn</code> and postsynaptic sites (inputs) are put under <code>nrn.anno.post_syn</code>. For example, <code>nrn.anno.post_syn.df.head()</code> will show the first few post-synaptic sites:</p> id size pre_pt_supervoxel_id post_pt_supervoxel_id post_pt_root_id pre_pt_position post_pt_position ctr_pt_position post_pt_level2_id post_pt_mesh_ind post_pt_mesh_ind_filt 0 172461633 15200 90359378338883207 90359378338887551 864691135397503777 [745048. 418840. 888160.] [744744. 419112. 888240.] [744776. 419024. 888160.] 162416972376572296 7995 7995 1 142677506 22532 88108334439511704 88108265720062299 864691135397503777 [678880. 441128. 890840.] [679104. 440728. 890800.] [679216. 440768. 890720.] 160165859757654524 3412 3412 2 145066644 4532 88036110403862351 88036110403865679 864691135397503777 [677880. 387048. 939680.] [677400. 387152. 939720.] [677648. 387344. 939760.] 160093704441299965 3236 3236 3 170547369 2320 90357866644502688 90357866644495463 864691135397503777 [743560. 374824. 925320.] [743824. 374696. 924840.] [743512. 374784. 925040.] 162415460682301674 7940 7940 4 149896539 2660 88811815655855809 88882184400027792 864691135397503777 [700472. 436192. 873960.] [700576. 436056. 874120.] [700536. 436168. 874080.] 160939778437546796 4447 4447 <p>Note the <code>mesh_ind</code> column, which aligns with the mesh indices in the <code>nrn.mesh</code> attribute.</p>"},{"location":"tutorial/#using-features","title":"Using Features","text":"<p>Skeletions are only so useful on their own, one also wants to attach properties like dendritic compartments to them for analysis. There are a few convenience functions in <code>pcg_skel.features</code> that can be used to add features to a skeleton. All of these functions start use the level 2 chunks and collect a variety of features either from the l2cache or CAVE database.</p>"},{"location":"tutorial/#synapses","title":"Synapses","text":"<p>The best way to get synapses is by default through the <code>pcg_meshwork</code> function, which handles the complexity of synapse queries and attachment. Once created, these synapses can be used to generate two different mappings of the neuron. The first creates a count of the number of synapses per skeleton vertex while dropping connectivity information, and the second uses synapses to predict which parts of the skeleton are dendritic and which are axonal.</p> <p>To get the synapse count map, use the <code>features.add_synapse_count</code> function. For example, assuming you have a pcg meshwork object <code>nrn</code> with synapses attached in the default way, we can add synapse counts to the skeleton with:</p> <pre><code>pcg_skel.features.add_synapse_count(\n    nrn,\n)\n\nsyn_count_df = nrn.anno.synapse_count.df\n</code></pre> <p>The resulting dataframe by default will create a dataframe with one row per graph vertex (not skeleton vertex!) and columns:</p> <ul> <li><code>num_syn_in</code>: The number of input synapse at the vertex</li> <li><code>num_syn_out</code>: The number of output synapse at the vertex</li> <li><code>net_size_in</code>: The summed size of the input synapses at the vertex.</li> <li><code>net_size_out</code>: The summed size of the output synapses at the vertex.</li> </ul> <p>The last two columns enable one to compute averages of synapse size, although not percentiles.</p> <p>If you want to map these values to skeleton nodes, there is also a function to handle this aggregation.</p> <pre><code>skel_df = pcg_skel.features.aggregate_property_to_skeleton(\n    nrn,\n    'synapse_count',\n    agg_dict={'num_syn_in': 'sum', 'num_syn_out': 'sum', 'net_size_in': 'sum', 'net_size_out': 'sum'},\n)\n</code></pre> <p>This will generate a dataframe with one row per skeleton vertex and the columns will aggregate the synapse count properties to the skeleton. The <code>agg_dict</code> property lets you specify exactly which columns to aggregate by across associated graph vertices and how to aggregate them. Anything that works in a pandas groupby operation will work here. Note that if you don't specify a column in the <code>agg_dict</code>, nothing will happen to it.</p>"},{"location":"reference/features/","title":"features","text":"<p>Helper functions for adding features from the L2cache to skeletons</p> <p>Functions:</p> <ul> <li> <code>add_is_axon_annotation</code>             \u2013              <p>Add an annotation property table specifying which vertices belong to the axon, based on synaptic input and output locations</p> </li> <li> <code>add_lvl2_ids</code>             \u2013              <p>Add meshwork annotation table associating level 2 ids with vertex ids.</p> </li> <li> <code>add_segment_properties</code>             \u2013              <p>Use volumetric and topological properties to add descriptive properties for each skeleton vertex.</p> </li> <li> <code>add_synapse_count</code>             \u2013              <p>Create a synapse count label across mesh vertices from existing synapse annotation.</p> </li> <li> <code>add_synapses</code>             \u2013              <p>Add synapses to a meshwork object based on l2ids</p> </li> <li> <code>add_volumetric_properties</code>             \u2013              <p>Add L2 Cache properties as an annotation property table.</p> </li> <li> <code>aggregate_property_to_skeleton</code>             \u2013              <p>Aggregate a meshwork annotation table to skeletons</p> </li> </ul>"},{"location":"reference/features/#pcg_skel.features.add_is_axon_annotation","title":"<code>add_is_axon_annotation(nrn, pre_anno, post_anno, annotation_name='is_axon', threshold_quality=0.5, extend_to_segment=True, n_times=1, return_quality=False)</code>","text":"<p>Add an annotation property table specifying which vertices belong to the axon, based on synaptic input and output locations For the synapse flow centrality algorithm, see \"Quantitative neuroanatomy for connectomics in Drosophila\", Schneider-Mizell et al. eLife 2016.</p> <p>Parameters:</p> <ul> <li> <code>nrn</code>               (<code>Meshwork</code>)           \u2013            <p>Meshwork object</p> </li> <li> <code>pre_anno</code>               (<code>str</code>)           \u2013            <p>Annotation property table name for presynaptic sites (outputs).</p> </li> <li> <code>post_anno</code>               (<code>str</code>)           \u2013            <p>Annotation property table name for postsyanptic sites (inputs).</p> </li> <li> <code>annotation_name</code>               (<code>str</code>, default:                   <code>'is_axon'</code> )           \u2013            <p>Name of the new table specifying axon indices, by default \"is_axon\"</p> </li> <li> <code>threshold_quality</code>               (<code>float</code>, default:                   <code>0.5</code> )           \u2013            <p>Value between 0 and 1 setting the lower limit on input/output segregation quality, by default 0.5. If the segregatation quality is lower than this, a table is added but no vertices will be in the table.</p> </li> <li> <code>extend_to_segment</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the axon split point will be moved to the most root-ward point on the segment containing the highest synapse flow centrality, by default True</p> </li> <li> <code>n_times</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of times to run axon/dendrite detection in a row, by default 1. This should be set to the number of distinct axon branches on a cell, which surprisingly can be more than one even for mouse neurons.</p> </li> <li> <code>return_quality</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, returns the split quality score (a float between 0-1). Default is False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>split_quality</code>           \u2013            <p>Float between 0-1, with higher numbers indicating a better axon/dendrite segregation.</p> </li> </ul>"},{"location":"reference/features/#pcg_skel.features.add_lvl2_ids","title":"<code>add_lvl2_ids(nrn, l2dict_mesh, property_name='lvl2_ids')</code>","text":"<p>Add meshwork annotation table associating level 2 ids with vertex ids.</p> <p>Parameters:</p> <ul> <li> <code>nrn</code>               (<code>Meshwork</code>)           \u2013            <p>Meshwork object</p> </li> <li> <code>l2dict_mesh</code>               (<code>dict</code>)           \u2013            <p>Dictionary mapping L2 ids to mesh graph indices.</p> </li> <li> <code>property_name</code>               (<code>str</code>, default:                   <code>'lvl2_ids'</code> )           \u2013            <p>Name of the annotation table, by default \"lvl2_ids\"</p> </li> </ul>"},{"location":"reference/features/#pcg_skel.features.add_segment_properties","title":"<code>add_segment_properties(nrn, segment_property_name='segment_properties', effective_radius=True, area_factor=True, strahler=True, strahler_by_compartment=False, volume_property_name='vol_prop', volume_col_name='size_nm3', area_col_name='area_nm2', root_as_sphere=True, comp_mask='is_axon')</code>","text":"<p>Use volumetric and topological properties to add descriptive properties for each skeleton vertex. Note that properties are estimated per segment, the unbranched region between branch points and/or endpoints.</p> <p>This function assumes that the volume properties have already been added to the meshwork, which can be done using <code>add_volumetric_properties</code>.</p> <p>Parameters:</p> <ul> <li> <code>nrn</code>               (<code>Meshwork</code>)           \u2013            <p>Meshwork object</p> </li> <li> <code>segment_property_name</code>               (<code>str</code>, default:                   <code>'segment_properties'</code> )           \u2013            <p>Name of the new annotation property table, by default \"segment_properties\"</p> </li> <li> <code>effective_radius</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, add a column for a radius estimate found by computing the radius of an equivalent cylindar with the same length and volume as each segment, by default True</p> </li> <li> <code>area_factor</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, add a column with the ratio of the surface area of the segment and the surface area of an equivalent cylinder (without endcaps), by default True</p> </li> <li> <code>strahler</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, add a column with the strahler number of the segment, by default True</p> </li> <li> <code>strahler_by_compartment</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, computer strahler number for axon and dendrite separately, using the annotation property table specified in <code>comp_mask</code>, by default False</p> </li> <li> <code>volume_property_name</code>               (<code>str</code>, default:                   <code>'vol_prop'</code> )           \u2013            <p>Name of the volume properties table as generated by the function <code>add_volumetric_properties</code>, by default \"vol_prop\"</p> </li> <li> <code>volume_col_name</code>               (<code>str</code>, default:                   <code>'size_nm3'</code> )           \u2013            <p>Name of the column holding volume, by default \"size_nm3\"</p> </li> <li> <code>area_col_name</code>               (<code>str</code>, default:                   <code>'area_nm2'</code> )           \u2013            <p>Name of the column holding surface area, by default \"area_nm2\"</p> </li> <li> <code>root_as_sphere</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Treats the root location as a sphere for setting the effective radius, by default True</p> </li> <li> <code>comp_mask</code>               (<code>str</code>, default:                   <code>'is_axon'</code> )           \u2013            <p>Sets the annotation table to mask off for strahler number computation, by default \"is_axon\".</p> </li> </ul>"},{"location":"reference/features/#pcg_skel.features.add_synapse_count","title":"<code>add_synapse_count(nrn, anno_name='synapse_count', pre_syn='pre_syn', post_syn='post_syn', pre_syn_index='pre_pt_mesh_ind', post_syn_index='post_pt_mesh_ind', aggregate_size=True)</code>","text":"<p>Create a synapse count label across mesh vertices from existing synapse annotation.</p> <p>This function adds a synapse count annotation to the mesh vertices of a neuron. It aggregates synapse data from pre-synaptic and post-synaptic annotations and optionally calculates the mean size of the synapses.</p> <p>Parameters:</p> <ul> <li> <code>nrn</code>               (<code>Meshwork</code>)           \u2013            <p>The neuron meshwork object containing the mesh and annotations.</p> </li> <li> <code>anno_name</code>               (<code>str</code>, default:                   <code>'synapse_count'</code> )           \u2013            <p>The name of the annotation table to be created, by default \"synapse_count\".</p> </li> <li> <code>pre_syn</code>               (<code>str</code>, default:                   <code>'pre_syn'</code> )           \u2013            <p>The name of the pre-synaptic annotation table, by default \"pre_syn\". If set to None, presynaptic points will be skipped.</p> </li> <li> <code>post_syn</code>               (<code>str</code>, default:                   <code>'post_syn'</code> )           \u2013            <p>The name of the post-synaptic annotation table, by default \"post_syn\". If set to None, postsynaptic points will be skipped</p> </li> <li> <code>pre_syn_index</code>               (<code>str</code>, default:                   <code>'pre_pt_mesh_ind'</code> )           \u2013            <p>The mesh index column for pre-synaptic annotation, by default \"pre_pt_mesh_ind\".</p> </li> <li> <code>post_syn_index</code>               (<code>str</code>, default:                   <code>'post_pt_mesh_ind'</code> )           \u2013            <p>The mesh index column for post-synaptic annotation, by default \"post_pt_mesh_ind\".</p> </li> <li> <code>aggregate_size</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to aggregate the size of synapses, by default True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>The function modifies the neuron meshwork object in place by adding the synapse count annotation.</p> </li> </ul>"},{"location":"reference/features/#pcg_skel.features.add_synapses","title":"<code>add_synapses(nrn, synapse_table, l2dict_mesh, client, root_id=None, pre=False, post=False, remove_self_synapse=True, timestamp=None, live_query=False, metadata=False, synapse_partners=False, synapse_point_resolution=None, synapse_representative_point_pre='ctr_pt_position', synapse_representative_point_post='ctr_pt_position', synapse_reference_tables={})</code>","text":"<p>Add synapses to a meshwork object based on l2ids</p> <p>Parameters:</p> <ul> <li> <code>nrn</code>               (<code>Meshwork</code>)           \u2013            <p>Meshwork object</p> </li> <li> <code>synapse_table</code>               (<code>str</code>)           \u2013            <p>Annotation table to use for synapses</p> </li> <li> <code>l2dict_mesh</code>               (<code>dict</code>)           \u2013            <p>Dictionary mapping l2ids to vertex ids</p> </li> <li> <code>client</code>               (<code>CAVEclient</code>)           \u2013            <p>Caveclient to use to get annotations</p> </li> <li> <code>root_id</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Root id of the cell, by default None. If none, uses the root id set in nrn.seg_id.</p> </li> <li> <code>pre</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, add presynaptic synpases (i.e. outputs), by default False</p> </li> <li> <code>post</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, add postsynaptic synapses (i.e. inputs), by default False</p> </li> <li> <code>remove_self_synapse</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, omit synapses where the pre and post root ids are the same, by default True</p> </li> <li> <code>timestamp</code>               (<code>datetime</code>, default:                   <code>None</code> )           \u2013            <p>Datetime to use for root id lookups if not using a materialized version, by default None</p> </li> <li> <code>live_query</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, use a timestamp to look up root ids, by default False</p> </li> <li> <code>synapse_partners</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, returns the root id of synapses partners in the dataframe. By default, this is False because partner root ids change with editing and are not specified by this cell's data alone.</p> </li> </ul>"},{"location":"reference/features/#pcg_skel.features.add_volumetric_properties","title":"<code>add_volumetric_properties(nrn, client, attributes=VOL_PROPERTIES, l2id_anno_name='lvl2_ids', l2id_col_name='lvl2_id', property_name='vol_prop')</code>","text":"<p>Add L2 Cache properties as an annotation property table.</p> <p>Parameters:</p> <ul> <li> <code>nrn</code>               (<code>Meshwork</code>)           \u2013            <p>Meshwork object</p> </li> <li> <code>client</code>               (<code>CAVEclient</code>)           \u2013            <p>Initialized caveclient</p> </li> <li> <code>attributes</code>               (<code>list</code>, default:                   <code>VOL_PROPERTIES</code> )           \u2013            <p>List of attributes to download, by default: [\"area_nm2\", \"size_nm3\", \"mean_dt_nm\", \"max_dt_nm\"].</p> </li> <li> <code>l2id_anno_name</code>               (<code>str</code>, default:                   <code>'lvl2_ids'</code> )           \u2013            <p>Name of the annotation property table holding L2 ids, by default \"lvl2_ids\"</p> </li> <li> <code>l2id_col_name</code>               (<code>str</code>, default:                   <code>'lvl2_id'</code> )           \u2013            <p>Name of the column in the property table holding L2 ids, by default \"lvl2_id\"</p> </li> <li> <code>property_name</code>               (<code>str</code>, default:                   <code>'vol_prop'</code> )           \u2013            <p>Name of the new volume property table, by default \"vol_prop\"</p> </li> </ul>"},{"location":"reference/features/#pcg_skel.features.aggregate_property_to_skeleton","title":"<code>aggregate_property_to_skeleton(nrn, anno_table, agg_dict=None, fill_value=0)</code>","text":"<p>Aggregate a meshwork annotation table to skeletons</p> <p>Parameters:</p> <ul> <li> <code>nrn</code>               (<code>Meshwork</code>)           \u2013            <p>Meshwork object with mesh,skeleton, and annotations</p> </li> <li> <code>anno_table</code>               (<code>str</code>)           \u2013            <p>Name of the annotation table</p> </li> <li> <code>agg_dict</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of column names and aggregation functions that can be used by pandas pd.NamedAgg.</p> </li> <li> <code>fill_value</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>Value to use to fill missing or NaN values, by default 0</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Dataframe with one row per skeleton index and columns aggregating mesh annotation values using the aggregation function specified in the aggregation_dict.</p> </li> </ul>"},{"location":"reference/pcg_anno/","title":"pcg_anno","text":"<p>Helper functions for adding annotations to neurons generated by pcg_skel.</p> <p>Functions:</p> <ul> <li> <code>annotation_to_level2_id</code>             \u2013              <p>Add or more level2_id columns to a dataframe based on supervoxel columns</p> </li> <li> <code>annotation_to_mesh_index</code>             \u2013              <p>Map level2 ids to mesh indices.</p> </li> <li> <code>get_level2_synapses</code>             \u2013              <p>Retrieve level 2 synapses for a given root ID.</p> </li> </ul>"},{"location":"reference/pcg_anno/#pcg_skel.pcg_anno.annotation_to_level2_id","title":"<code>annotation_to_level2_id(df, client, bound_pt_columns='pt', l2_suffix='_level2_id', sv_columns=None, l2_columns=None, inplace=False, timestamp=None)</code>","text":"<p>Add or more level2_id columns to a dataframe based on supervoxel columns</p> <p>Parameters:</p> <ul> <li> <code>df</code>               (<code>DataFrame</code>)           \u2013            <p>DataFrame with one or more supervoxel columns</p> </li> <li> <code>client</code>               (<code>CAVEclient or ChunkedgraphClient</code>)           \u2013            <p>Client for interacting with the chunkedgraph</p> </li> <li> <code>bound_pt_columns</code>               (<code>str or list - like</code>, default:                   <code>'pt'</code> )           \u2013            <p>List of bound spatial point names, prefix only. E.g. 'pt' for an annotation with 'pt_position', 'pt_supervoxel_id', and 'pt_root_id'. Optional, by default 'pt'.</p> </li> <li> <code>l2_suffix</code>               (<code>str</code>, default:                   <code>'_level2_id'</code> )           \u2013            <p>Suffix to use for new level 2 id column, by default '_level2_id'</p> </li> <li> <code>sv_columns</code>               (<code>str or list - like</code>, default:                   <code>None</code> )           \u2013            <p>Explicit list of level 2 columns, not needed if using bound_pt_columns. By default None</p> </li> <li> <code>l2_columns</code>               (<code>[type]</code>, default:                   <code>None</code> )           \u2013            <p>Explicit list of desired level 2 columns, not needed if using bound_pt_columns. By default None</p> </li> <li> <code>inplace</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, change the dataframe in place, by default False</p> </li> <li> <code>timestamp</code>               (<code>datetime or None</code>, default:                   <code>None</code> )           \u2013            <p>Timestamp to lookup the mapping. If None, uses the materialization version timestamp. Default is None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>DataFrame with level 2 id columns added</p> </li> </ul>"},{"location":"reference/pcg_anno/#pcg_skel.pcg_anno.annotation_to_mesh_index","title":"<code>annotation_to_mesh_index(df, l2dict, level2_id_col='pt_level2_id', mesh_index_col='pt_mesh_ind', inplace=False)</code>","text":"<p>Map level2 ids to mesh indices.</p> <p>Parameters:</p> <ul> <li> <code>df</code>               (<code>DataFrame</code>)           \u2013            <p>DataFrame with at least one level 2 id column</p> </li> <li> <code>l2dict</code>               (<code>dict</code>)           \u2013            <p>Dict of level2 id to mesh index mappings</p> </li> <li> <code>level2_id_col</code>               (<code>str or list</code>, default:                   <code>'pt_level2_id'</code> )           \u2013            <p>Level 2 id column or list of columns, by default 'pt_level2_id'</p> </li> <li> <code>mesh_index_col</code>               (<code>str</code>, default:                   <code>'pt_mesh_ind'</code> )           \u2013            <p>Column name (or names) to use for added mesh index, by default 'pt_mesh_ind'</p> </li> <li> <code>inplace</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If False, makes changes on a copy of the dataframe, by default False</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>DataFrame with mesh index column/s added</p> </li> </ul>"},{"location":"reference/pcg_anno/#pcg_skel.pcg_anno.get_level2_synapses","title":"<code>get_level2_synapses(root_id, l2dict, client, synapse_table, remove_self=True, pre=True, post=True, live_query=False, timestamp=None, metadata=False, synapse_point_resolution=None, synapse_reference_tables={})</code>","text":"<p>Retrieve level 2 synapses for a given root ID.</p> <p>Parameters:</p> <ul> <li> <code>root_id</code>               (<code>int</code>)           \u2013            <p>The root ID for which to retrieve synapses.</p> </li> <li> <code>l2dict</code>               (<code>dict</code>)           \u2013            <p>Dict of level2 id to mesh index mappings</p> </li> <li> <code>client</code>               (<code>object</code>)           \u2013            <p>The client object used for querying the synapse data.</p> </li> <li> <code>synapse_table</code>               (<code>str</code>)           \u2013            <p>The name of the synapse table to query.</p> </li> <li> <code>remove_self</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to remove self-synapses. Defaults to True.</p> </li> <li> <code>pre</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to retrieve pre-synapses. Defaults to True.</p> </li> <li> <code>post</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to retrieve post-synapses. Defaults to True.</p> </li> <li> <code>live_query</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to perform a live query. Defaults to False.</p> </li> <li> <code>timestamp</code>               (<code>datetime</code>, default:                   <code>None</code> )           \u2013            <p>The timestamp for the live query. Defaults to None.</p> </li> <li> <code>metadata</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to include metadata in the query results. Defaults to False.</p> </li> <li> <code>synapse_point_resolution</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>The resolution of the synapse points. Defaults to None.</p> </li> <li> <code>synapse_reference_tables</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>A dictionary of synapse reference tables to attach to synapses. Keys are 'pre' and 'post', values are table names. Defaults to {}.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>pre_syn_df</code> (              <code>DataFrame or None</code> )          \u2013            <p>The DataFrame containing pre-synapse data, or None if pre is False.</p> </li> <li> <code>post_syn_df</code> (              <code>DataFrame or None</code> )          \u2013            <p>The DataFrame containing post-synapse data, or None if post is False.</p> </li> </ul>"},{"location":"reference/pcg_skel/","title":"pcg_skel","text":"<p>Basic functions for generating chunk-resolution skeletons from a pychunkedgraph.</p> <p>Functions:</p> <ul> <li> <code>pcg_graph</code>             \u2013              <p>Compute the level 2 spatial graph (or mesh) of a given root id using the l2cache.</p> </li> <li> <code>pcg_skeleton</code>             \u2013              <p>Produce a skeleton from the level 2 graph.</p> </li> <li> <code>pcg_skeleton_direct</code>             \u2013              <p>Produce a skeleton from an already-computed l2graph.</p> </li> <li> <code>pcg_meshwork</code>             \u2013              <p>Generate a meshwork file based on the level 2 graph.</p> </li> </ul>"},{"location":"reference/pcg_skel/#pcg_skel.pcg_skel.pcg_graph","title":"<code>pcg_graph(root_id, client, cv=None, return_l2dict=False, nan_rounds=10, require_complete=False, level2_graph=None)</code>","text":"<p>Compute the level 2 spatial graph (or mesh) of a given root id using the l2cache.</p> <p>Parameters:</p> <ul> <li> <code>root_id</code>               (<code>int</code>)           \u2013            <p>Root id of a segment</p> </li> <li> <code>client</code>               (<code>caveclient</code>)           \u2013            <p>Initialized CAVEclient for the dataset.</p> </li> <li> <code>cv</code>               (<code>CloudVolume</code>, default:                   <code>None</code> )           \u2013            <p>Initialized CloudVolume object for the dataset. This does not replace the caveclient, but a pre-initizialized cloudvolume can save some time during batch processing.</p> </li> <li> <code>return_l2dict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, returns the mappings between l2 ids and vertices.</p> </li> <li> <code>nan_rounds</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>If vertices are missing (or not computed), this sets the number of iterations for smoothing over them.</p> </li> <li> <code>require_complete</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, raise an Exception if any vertices are missing from the cache.</p> </li> <li> <code>level2_graph</code>               (<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>Level 2 graph for the root id as returned by client.chunkedgraph.level2_chunk_graph. A list of lists of edges between level 2 chunks, as defined by their chunk ids. If None, will query the chunkedgraph for the level 2 graph. Optional, by default None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mesh</code> (              <code>Mesh</code> )          \u2013            <p>Object with a vertex for every level 2 id and edges between all connected level 2 chunks.</p> </li> <li> <code>l2dict</code> (              <code>(dict, optional)</code> )          \u2013            <p>Dictionary with keys as level 2 ids and values as mesh vertex index. Optional, only returned if <code>return_l2dict</code> is True.</p> </li> <li> <code>l2dict_reverse</code> (              <code>(dict, optional)</code> )          \u2013            <p>Dictionary with keys as mesh vertex indices and values as level 2 id. Optional, only returned if <code>return_l2dict</code> is True.</p> </li> </ul>"},{"location":"reference/pcg_skel/#pcg_skel.pcg_skel.pcg_skeleton","title":"<code>pcg_skeleton(root_id, client, datastack_name=None, cv=None, invalidation_d=7500, return_mesh=False, return_l2dict=False, return_l2dict_mesh=False, root_point=None, root_point_resolution=None, collapse_soma=False, collapse_radius=7500, nan_rounds=10, require_complete=False, level2_graph=None)</code>","text":"<p>Produce a skeleton from the level 2 graph.</p> <p>Parameters:</p> <ul> <li> <code>root_id</code>               (<code>int</code>)           \u2013            <p>Root id of a segment</p> </li> <li> <code>client</code>               (<code>CAVEclientFull</code>)           \u2013            <p>Initialized CAVEclient for the dataset.</p> </li> <li> <code>datastack_name</code>               (<code>string</code>, default:                   <code>None</code> )           \u2013            <p>If client is None, initializes a CAVEclient at this datastack.</p> </li> <li> <code>cv</code>               (<code>CloudVolume</code>, default:                   <code>None</code> )           \u2013            <p>Initialized CloudVolume object for the dataset. This does not replace the caveclient, but a pre-initizialized cloudvolume can save some time during batch processing.</p> </li> <li> <code>invalidation_d</code>               (<code>int</code>, default:                   <code>7500</code> )           \u2013            <p>Distance (in nanometers) for TEASAR skeleton invalidation.</p> </li> <li> <code>return_mesh</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, returns the mesh graph as well as the skeleton.</p> </li> <li> <code>return_l2dict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, returns the mappings between l2 ids and skeleton vertices.</p> </li> <li> <code>return_l2dict_mesh</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, returns mappings between l2 ids and mesh graph vertices.</p> </li> <li> <code>root_point</code>               (<code>ArrayLike</code>, default:                   <code>None</code> )           \u2013            <p>3-element list or array with the x,y,z location of the root point. If None, the most distant tip is set to root.</p> </li> <li> <code>root_point_resolution</code>               (<code>ArrayLike</code>, default:                   <code>None</code> )           \u2013            <p>3-element list or array with the x,y,z resolution of the root point, in nanometers per voxel dimension.</p> </li> <li> <code>collapse_soma</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, collapse nearby vertices into the root point.</p> </li> <li> <code>collapse_radius</code>               (<code>int</code>, default:                   <code>7500</code> )           \u2013            <p>Distance (in nanometers) for soma collapse.</p> </li> <li> <code>nan_rounds</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>If vertices are missing (or not computed), this sets the number of iterations for smoothing over them.</p> </li> <li> <code>require_complete</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, raise an Exception if any vertices are missing from the cache.</p> </li> <li> <code>level2_graph</code>               (<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>Level 2 graph for the root id as returned by client.chunkedgraph.level2_chunk_graph. A list of lists of edges between level 2 chunks, as defined by their chunk ids. If None, will query the chunkedgraph for the level 2 graph. Optional, by default None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>sk</code> (              <code>Skeleton</code> )          \u2013            <p>Skeleton for the root id</p> </li> <li> <code>mesh</code> (              <code>(Mesh, optional)</code> )          \u2013            <p>Mesh graph that the skeleton is based on, only returned if return_mesh is True.</p> </li> <li> <code>(l2dict_skel, l2dict_skel_reverse): (dict, dict), optional</code>           \u2013            <p>Dictionaries mapping l2 ids to skeleton vertices and skeleton vertices to l2 ids, respectively. Only returned if return_l2dict is True.</p> </li> <li> <code>(l2dict_mesh, l2dict_mesh_reverse): (dict, dict), optional</code>           \u2013            <p>Dictionaries mapping l2 ids to mesh graph vertices and mesh_graph vertices to l2 ids, respectively. Only returned if return_l2dict is True.</p> </li> </ul>"},{"location":"reference/pcg_skel/#pcg_skel.pcg_skel.pcg_skeleton_direct","title":"<code>pcg_skeleton_direct(vertices, edges, invalidation_d=DEFAULT_INVALIDATION_D, root_point=None, collapse_soma=False, collapse_radius=DEFAULT_COLLAPSE_RADIUS, root_id=None)</code>","text":"<p>Produce a skeleton from an already-computed l2graph. This is effectively a wrapper for meshparty skeletonize with a consistent set of parameters and format.</p> <p>Parameters:</p> <ul> <li> <code>vertices</code>               (<code>array</code>)           \u2013            <p>Array of vertices for the mesh graph.</p> </li> <li> <code>edges</code>               (<code>array</code>)           \u2013            <p>Array of edges for the mesh graph.</p> </li> <li> <code>invalidation_d</code>               (<code>int</code>, default:                   <code>DEFAULT_INVALIDATION_D</code> )           \u2013            <p>Distance (in nanometers) for TEASAR skeleton invalidation.</p> </li> <li> <code>root_point</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            <p>3-element list or array with the x,y,z location of the root point in same units as vertices. If None, the most distant tip is set to root.</p> </li> <li> <code>collapse_soma</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, collapse nearby vertices into the root point.</p> </li> <li> <code>collapse_radius</code>               (<code>int</code>, default:                   <code>DEFAULT_COLLAPSE_RADIUS</code> )           \u2013            <p>Distance (in nanometers) for soma collapse.</p> </li> <li> <code>root_id</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Root id of the segment, used in metadata. Optional, by default None.</p> </li> <li> <code>level2_graph</code>               (<code>ndarray</code>)           \u2013            <p>Level 2 graph for the root id as returned by client.chunkedgraph.level2_chunk_graph. A list of lists of edges between level 2 chunks, as defined by their chunk ids. If None, will query the chunkedgraph for the level 2 graph. Optional, by default None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>sk</code> (              <code>Skeleton</code> )          \u2013            <p>Skeleton for the l2graph.</p> </li> </ul>"},{"location":"reference/pcg_skel/#pcg_skel.pcg_skel.pcg_meshwork","title":"<code>pcg_meshwork(root_id, datastack_name=None, client=None, cv=None, root_point=None, root_point_resolution=None, collapse_soma=False, collapse_radius=DEFAULT_COLLAPSE_RADIUS, synapses=None, synapse_table=None, remove_self_synapse=True, synapse_reference_tables={}, live_query=False, timestamp=None, invalidation_d=DEFAULT_INVALIDATION_D, require_complete=False, metadata=False, synapse_partners=False, synapse_point_resolution=[1, 1, 1], synapse_representative_point_pre='ctr_pt_position', synapse_representative_point_post='ctr_pt_position', level2_graph=None)</code>","text":"<p>Generate a meshwork file based on the level 2 graph.</p> <p>Parameters:</p> <ul> <li> <code>root_id</code>               (<code>int</code>)           \u2013            <p>Root id of an object in the pychunkedgraph.</p> </li> <li> <code>datastack_name</code>               (<code>str or None</code>, default:                   <code>None</code> )           \u2013            <p>Datastack name to use to initialize a client, if none is provided. By default None.</p> </li> <li> <code>client</code>               (<code>CAVEclientFull or None</code>, default:                   <code>None</code> )           \u2013            <p>Initialized CAVE client. If None is given, will use the datastack_name to create one. By default None</p> </li> <li> <code>cv</code>               (<code>CloudVolume or None</code>, default:                   <code>None</code> )           \u2013            <p>Initialized cloudvolume. If none is given, the client info will be used to create one. By default None</p> </li> <li> <code>root_point</code>               (<code>array - like or None</code>, default:                   <code>None</code> )           \u2013            <p>3 element xyz location for the location to set the root in units set by root_point_resolution, by default None. If None, a distal tip is selected.</p> </li> <li> <code>root_point_resolution</code>               (<code>array - like</code>, default:                   <code>None</code> )           \u2013            <p>Resolution in euclidean space of the root_point, by default [4, 4, 40]</p> </li> <li> <code>collapse_soma</code>               (<code>(bool, optional)</code>, default:                   <code>False</code> )           \u2013            <p>If True, collapses vertices within a given radius of the root point into the root vertex, typically to better represent primary neurite branches. Requires a specified root_point. Default if False.</p> </li> <li> <code>collapse_radius</code>               (<code>float</code>, default:                   <code>DEFAULT_COLLAPSE_RADIUS</code> )           \u2013            <p>Max distance in euclidean space for soma collapse. Default is 10,000 nm (10 microns).</p> </li> <li> <code>synapses</code>               (<code>'pre', 'post', 'all', True, or None</code>, default:                   <code>None</code> )           \u2013            <p>If not None, queries the synapse_table for presynaptic synapses (if 'pre'),  postsynaptic sites (if 'post'), or both (if 'all' or True). By default None</p> </li> <li> <code>synapse_table</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Name of the synapse table to query if synapses are requested, by default None</p> </li> <li> <code>remove_self_synapse</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, filters out synapses whose pre- and postsynaptic root ids are the same neuron, by default True</p> </li> <li> <code>synapse_reference_tables</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>A dictionary of synapse reference tables to attach to synapses. Keys are 'pre' and 'post', values are table names. Defaults to {}.</p> </li> <li> <code>live_query</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, expect a timestamp for querying at a give point in time. Otherwise, use the materializatio set by the client. Optional, by default False.</p> </li> <li> <code>timestamp</code>               (<code>Optional[datetime]</code>, default:                   <code>None</code> )           \u2013            <p>If set, acts as the time at which all root ids and annotations are found at.</p> </li> <li> <code>invalidation_d</code>               (<code>int</code>, default:                   <code>DEFAULT_INVALIDATION_D</code> )           \u2013            <p>Invalidation radius in hops for the mesh skeletonization along the chunk adjacency graph, by default 3</p> </li> <li> <code>require_complete</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, raise an Exception if any vertices are missing from the cache, by default False</p> </li> <li> <code>metadata</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, adds metadata to the meshwork annotations. By default False.</p> </li> <li> <code>synapse_partners</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, includes the partner root id to the synapse annotation. By default False, because partner roots can change across time.</p> </li> <li> <code>synapse_point_resolution</code>               (<code>array - like</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>Resolution in euclidean space of the synapse points, by default None. If None, the resolution will be the default of the synapse table.</p> </li> <li> <code>synapse_representative_point_pre</code>               (<code>str</code>, default:                   <code>'ctr_pt_position'</code> )           \u2013            <p>If set, uses the specified column in the synapse table for the pre-synaptic points. By default 'ctr_pt_position'.</p> </li> <li> <code>synapse_representative_point_post</code>               (<code>str</code>, default:                   <code>'ctr_pt_position'</code> )           \u2013            <p>If set, uses the specified column in the synapse table for the post-synaptic points. By default 'ctr_pt_position'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Meshwork</code>           \u2013            <p>Meshwork object with skeleton based on the level 2 graph. See documentation for details.</p> </li> </ul>"},{"location":"reference/service/","title":"service","text":"<p>Rehydrating meshwork object from the CAVE skeleton service.</p> <p>Functions:</p> <ul> <li> <code>get_meshwork_from_client</code>             \u2013              <p>Generate a meshwork file from the information on the skeleton service.</p> </li> </ul>"},{"location":"reference/service/#pcg_skel.service.get_meshwork_from_client","title":"<code>get_meshwork_from_client(root_id, client, synapses=False, restore_graph=False, restore_properties=False, synapse_reference_tables={}, skeleton_version=4)</code>","text":"<p>Generate a meshwork file from the information on the skeleton service. Note: Requires skeleton service v0.12.3 or higher to be deployed.</p> <p>Parameters:</p> <ul> <li> <code>root_id</code>               (<code>int</code>)           \u2013            <p>Object root id</p> </li> <li> <code>client</code>               (<code>CAVEclient</code>)           \u2013            <p>Initialized caveclient</p> </li> <li> <code>synapses</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to add synapses under the annotations \"pre_syn\" and \"post_syn\", by default False</p> </li> <li> <code>restore_graph</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to restore the level 2 graph, by default False. Adds a significant amount of time to the rehydration, however the <code>nrn.mesh</code> part will not be accurate if this is True.</p> </li> <li> <code>restore_properties</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to restore <code>volume_properties</code> and <code>segment_properties</code>, by default False. Adds a significant amount of time to the rehydration.</p> </li> <li> <code>synapse_reference_tables</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>A dictionary of synapse reference tables to attach to synapses. Keys are 'pre' and 'post', values are table names. Defaults to {}.</p> </li> <li> <code>skeleton_version</code>               (<code>Optional[int]</code>, default:                   <code>4</code> )           \u2013            <p>Which skeleton version to use, by default 4, which is the minimum needed for rehydration to work.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MeshWork</code>           \u2013            <p>Meshwork object with annotation properties: * <code>compartment</code>: SWC compartment labels for vertices (1: soma, 2: axon, 3: dendrite) * <code>is_axon</code>: Vertices with compartment label 2. * <code>lvl2_ids</code>: Level 2 id for each vertex of the spatial graph. * <code>pre_syn</code> and <code>post_syn</code> (optional): Synapse information. * <code>segment_properties</code> and <code>volume_properties</code> (optional): Segment and volume information.</p> <p>Note that the spatial graph (<code>nrn.mesh</code>) part of the file will not be correct with this function unless <code>restore_graph</code> is set to True, but the skeleton and annotations will be.</p> </li> </ul>"}]}